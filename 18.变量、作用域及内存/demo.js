// alert('第十八章')


// Javascript的变量是松散型(不强制类型)
// ECMAScript变量可能包含两种不同的数据类型的值，基本类型值和引用类型值。基本类型值指的是那些保存在栈内存中的简单数据段，即这种值完全保存在内存中的一个位置。
// 而引用类型值则是指那些保存在堆内存中的对象，意思是变量中保存的实际上只是一个指针，这个指针指向内存中的另一个位置，该位置保存对象。
// 将一个值赋给变量时，解析器必须确定这个值是基本类型值，还是引用类型值，基本类型值有以下几种: Undefined、Null、Boolean、Number和String，这些类型在内存中
// 分别占有固定大小的空间，他们的值保存在栈空间，我们通过按值来访问的。
// PS: 在某些语言中，字符串以对象的形式来表示，因为被认为是引用类型，ECMAScript放弃这一传统。
// 如果赋值的是引用类型的值，则必须在堆内存中为这个值分配空间，由于这种值的大小不固定，因此不能把它们保存在栈内存中，但内存大小是固定的，因此可以将内存地址保存
// 栈内存中。这样，当查询引用类型的变量时，先从栈中读取内存地址，然后再通过地址找到堆中的值。对于这种，我们把它叫做按引用访问。


// 对象类型
var box = new Object();
box.name = 'Lee';
// alert(box.name);		// Lee

// 基本数据类型
var box = 'Lee';
box.age = 25;
// alert(box.age);		// undefined  不是引用类型  无法输出


// 复制变量值
// 在变量复制方面，基本类型和引用类型也有所不同，基本类型复制的是值本身，而引用类型复制的是地址。
// 重点: 无论是基本类型还是引用类型，他们复制操作的都是栈内存的东西，而堆内存的东西他们无法操作。因为基本类型的复制复制的是值本身，值本身存储在栈内存，只是在
// 栈内存又分配了个空间存储复制的值。而引用类型复制的是地址，刚才已经说过，引用类型复制的是地址，而地址放在栈内存中，所以也只是又分配了个空间，存储复制后的地址。
var box = 'Lee';		// 在栈内存生成一个box 'Lee'
var box1 = box;			// 在栈内存再生成一个box 'Lee'
// 上面基本数据类型，两行代码 box1 是虽然是box的一个副本，但从图示可以看出，它是完全独立的，也就是说，两个变量分别操作时互不影响


var box2 = new Object();   // 创建一个引用类型
box2.name = 'Lee';		   // 新增一个属性
var box3 = box2;		   // 把引用地址赋给box3
box3.name = 'nihao';
// alert(box2.name);		   
// 这里需要注意的是，当你把box2的地址复制给box3之后，因为他们地址同时指向同一块堆内存里面的内容，
// 所以当你改变box3的内容之后，该地址指向堆内存的内容也随之发生改变，而box2和box3指向的是同一个内容，所以获取box2指向的内容时，也会发生改变。


// 传递参数
// 1: 传递数值类型参数的例子
// ECMAScript中所有函数的参数都是按值传递的，言下之意就是说，参数不会按引用传递，虽然变量有基本类型和应用类型之分。
function box4 (num) {
	num += 10;		// 按值传递到，传递的参数是基本类型
	return num;		// 这里的num是局部变量，全局无效
};
var num = 50;
var result = box4(num);
// alert(result);	// 60
// alert(num);		// 50
// PS: 以上的代码中，传递的参数是一个基本类型的值，而函数里的num是一个局部变量，和外面的num没有任何联系。


// 2: 传递引用类型参数的例子
// 这里将要传递一个引用类型的参数，但是不是按引用传递，而是按值传递
// 所以 JS 没有按引用传参数的功能  切记  不能把传递引用参数当作按引用传参
// 你虽然传递的是一个对象，但它还是按值传递  它传递的是一个地址
function box5(obj) {
	obj.name = 'Lee';		// 按值传递，传递的参数是引用类型
};
var p = new Object();
box5(p);
// alert(p.name);

// 地处结论：ECMAScript函数的参数都将是局部变量，也就是说，没有按引用传递。
// 拓展知识：如果存在按引用传递的话，那么函数里的那个变量将会是全局变量，在外部也可以访问。比如: php。



// 检测类型
var box6 = 'Lee';
// alert(typeof box6);

// typeof在监测基本数据类型的时候非常好用，但是在监测对象类型的时候并不是那么好用。比如Object里面还分很多，数组 字典等都是对象，但是我们要知道具体哪一种。
var box7 = [1,2,3];
// alert(typeof box7);   // Object
var box8 = {};
// alert(typeof box8);   // Object
var box9 = /g/;
// alert(typeof box9);   // Object

// 上面的方式改成这样   instanceof如果用在监测基本数据类型  如果是new创建的 可以使用instanceof   如果是字面量的形式创建的  就需要用typeof
// alert(box7 instanceof Array);		// true
// alert(box8 instanceof Object);		// true
// alert(box9 instanceof RegExp);		// true




// 作用域和内存问题
var box10 = 'Lee';
function setBox() {
	return 123;
}
// alert(window.box10);		// 全局变量，最外围，属于window属性
// alert(window.setBox());		// 全局函数，最外围，属于window方法


// 这都和iOS的逻辑一样
var box11 = 'Lee';
function setBox() {
	box11 = 'nihao';
}
setBox();
// alert(box11);


// 函数体内包含函数
var box12 = 'Lee';
function setBox() {
	function setColor() {
		var b = 'kkkkk';
		return 123;
	}
	return setColor();
}
// alert(setBox());



// PS: 每个函数被调用时都会创建自己的执行环境，当执行到这个函数时，函数的环境就会被推到环境栈中去执行，而执行后又在环境栈中弹出(退出)，把控制权交给
// 上一级的执行环境。
// if 和 for 循环的作用域比较特殊
if (true) {
	var box13 = 'Lee';  // JS中 if 语句的花括号没有作用域的问题  
};
// alert(window.box13);		// Lee   box13都是window下的全局变量


for (var i = 0; i < 10; i++) {
	var box14 = 'nihao';	// JS中 for 语句的花括号没有作用域的问题  
}
alert(window.box14);	// nihao  box14都是window下的全局变量


// 想上搜索 但是我更愿意用一个词来修饰 就是 英语中的"就近原则"，这个iOS是同样的。
var box15 = 'Lee';
function setBox() {
	var box15 = 'red';
	return box15;
}
alert(setBox());




// 内存问题
// JS具有自动垃圾收集机制，也就是说，执行环境会负责管理代码执行过程中使用的内存，它会自行管理内存分配及无用内存的回收。

// JS最常用的垃圾收集方式是标记清除。垃圾收集器会在运行的时候给存储在内存中的变量加上标记。然后，它会去掉环境中正在使用变量的标记，而没有被去掉
// 标记的变量将被视为准备删除的变量。最后，垃圾收集器完成内存清理工作，销毁那些带标记的值并回收他们所占用的内存空间。

// 垃圾收集器是周期性运行的，这样会导致整个程序的性能问题，比如IE7以前的版本，它的垃圾收集器是根据内存分配量运行的，比如256个变量就开始运行垃圾收集器。这样，
// 就不得不频繁地运行，从而降低性能。

// 一般来说，确保占用最少的内存可以让页面获得更好的性能，那么优化内存的最佳方案，就是一旦数据不再有用，那么将其设置为null来释放引用。这个做法叫做解除
// 引用，这一做法适用于大多数全局变量和全局对象。
var person = {
	name:'Lee'
}
person = null;









































































































